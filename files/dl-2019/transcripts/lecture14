welcome to the final lesson of this section of 2019 although I guess it depends on the videos what order we end up doing the extra ones this is the final one that we're recording live here in San Francisco anyway lesson 14 lesson two of Alice special Swift episodes this is what we'll be covering today I won't read through it all but basically we're going to be filling in the gap between matrix multiplication and training imagenet with all the tricks and along the way we're going to be seeing a bunch of interesting swift features and actually seeing how they make our code cleaner safer faster I want to do a special shout out to a couple of our San Francisco study group members who have been particularly helpful over the last couple of weeks since I know nothing about it Swift it's been nice to have some folks who do such as Alexis who has been responsible actually for quite a some of the most exciting material you're going to see today and he is the CTO at topology eyewear so if you need classes you should definitely go there and get algorithmically designed glasses literally so that's pretty cool so thanks Alexis for your help and thanks also to Pedro who has almost single-handedly created this fantastic package cache that we have so that in your Jupiter notebooks you can you can import all the other modules that we're using and other exported modules in the notebooks and it doesn't have to recompile at all and so that's really thanks to Pedro and I actually am a customer of his as well or at least I was when I used an iPhone he's the developer of camera plus which is the most popular camera application on the App Store literally and back when I used an iPhone I loved that program so I'm sure version two is even better but I haven't tried version two so you can use his camera while looking through your topology I wear glasses alright so thanks both to both of you and where we left off last week was that I made a grand claim well I pointed out a couple of things I pointed out through this fantastic halide video that actually running low-level kind of CUDA kernel e stuff fast is actually much harder than just running a bunch of for loops in order and I showed you a some stuff based on halide which showed here's some ways that you can write it fast and here some ways you could do it quickly and then I made the bold claim that being able to do this on the GPU through Swift is where we're heading and so to find out how that's going to happen let's let's hear it directly from Chris sure thanks Jeremy so we will briefly talk about this so we went through this video and the author of how I'd give a great talk about how in image processing kernels there's actually a lot of different ways to get the computer to run this and they all have very different performance characteristics and it's really hard to take even a two-dimensional blur and make it go fast but we're doing something even harder we're not talking about two-dimensional images we're talking about 5d matrices and tensors and lots of different operations that are composed together and hundreds or thousands of ops and trying to make that'll go fastest is really really really really hard so if you want to do that what you do is you'd write a whole new compiler to do this and would take years and years of time but fortunately there's a great team at Google called the excel a team that has done all this for us and so what actually is is it's exactly one of those things it's something that takes in this graph of tensor operations so things like compositions and map moles and ads and and things like that it does low level optimizations to allocate buffers to take these different kernels and fuse them together and then it generates really high performance code that runs on things like CPUs GPUs or TP use which are crazy fast high-performance accelerators that Google has and so excellet does all this stuff for us now which is really exciting and if you take the running bachelor example the we left off with and we were talking about this is the graph that excellet will generate for you and this is generated from Swift code actually and so you can see here what these darker boxes are is there fusion nodes where it's taken a whole bunch of different operations push them together gotten rid of memory transfers pushed all the loops together and the cool thing about this is this is all existing shipping technology the tensile vote has now there's a big question though in a big big gotcha which is this only works if you have graphs and with dense flow one that was pretty straightforward because since the one was all about graphs Jeremy talked about the shipping shipping shipping ship ship ship shipping thingy ship ship shipping ship ship shoot I don't know my recursions wrong and so what's that so on it was really natural with dense flow to with PI torch there's a bigger problem which is with eager mode you don't have graphs that's the whole point is you want to have step at a time you run one off at a time and so you don't get the notion of these things so what the entire world is figured out is that there's two basic approaches of getting graphs from either mode there's tracing and there's different theories on tracing there's staging and taking code and turning it into a graph algorithmically and PI torch intensive low both have similar but different approaches to both of these different things the problem with these things they all have really weird side effects and they're very difficult to reason about and so the IFS watford hence flows an airplane we've taken off and we're just coming off the runway but we're still building all this stuff in just well for tensile flow as the plane is flying and so we don't actually have this today it's the team was working on the demo and it was just didn't come together today but this is this is really cool and so one of the problems with tracing for example is that in pi torture and tensorflow python when you trace if you have control flow in your model it will unroll the entire control flow and so if you have an RNN for example it will unroll the entire RNN and make one gigantic thing and some control flow you want to ignore some control flow you want to keep in the graph and so having more control over that is something that we think is really important so Chris this nearly there is as at end of April this video will be out somewhere around mid to late June Isis probably be up and running yeah and if it's not you will personally go to their house or the person watching the video and fix it for them so so look here's the deal in two three months so that's July okay look on the sofa tents full of main page there should be a collab demo showing this okay so we'll see we'll see how the future what they choose and there should be a notebook in the hairbrained repo that'll be called batch norm or something and we'll have an excel a version of this run yeah that's a list and so Swift also has this thing called graph program extraction basic idea here is that we're autograph and torch script are doing these things were they're kind of like Python but kind of not and Jeremy was talking before about how like you add a comment in the wrong place and torch script will fall over and it's it's not it kind of looks like Python but really really is not well swift we have a compiled reasonable language and so we could just use compiler techniques to form a graph pull it out for you and so a lot of things that are very magic and very weird are just very natural and plug into the system so I'm very excited about where all this comes but for right now this doesn't exist the airplane is being built so one last thing that doesn't exist because Jeremy wanted to talk about this he's very excited is there's this question but what does MOA are and how does my really text lay what is all this stuff going on how does this what does this make sense for tense flow and the way I look at this is the exploit is really good if you have if you want high performance with these common operators like matte matrix multiplication convolution things like that these operators can be combined in lots of different ways Ryan Bastion was a great example of this and so these are the primitives that a lot of deep learning is built out of and Excel a is really awesome for high performance particularly weird accelerators but there's a catch with this because one of the things that power deep learning is the ability to innovate in many of these ways and so depth wise convolutions came out and suddenly with many for your parameters you can get really good accuracy wins and you couldn't do that if you just had convolution yeah and like on the other hand like depth wise convolutions are a specific case of group convolutions and the reason we haven't been talking about group convolutions in class is that so far no one's really got them running quickly and so there's this whole thing that like somebody wrote paper about three years ago which basically says hey here's a way to get all the benefit of convolutions but much much faster and we're still you know the practical deep learning for coders cost still doesn't teach them because they're still not practical because no one's got them running quickly yet and so we've been talking about this whole course the goal with with this whole platform is to make it an infinitely hackable platform and so if it's infinitely hack well down a convolution or give up on performance or on a CPU well that's not good enough and so what mor is about is there's multiple different aspects of the project but but I think one Jeremy's most excited about it is what about custom ops right why how can we make it so you don't bottom out at matte mall and convolution and so you get that hack ability to invent the next great convolution so the cool thing about this is that this is a solved problem the problem is all the problems all the solutions are in these weird systems that don't talk to each other and they don't work well together and they're solving different slices of it so highlight for example is a really awesome system if you were looking for 2d image processing algorithms right that doesn't really help us other people have built systems on top of how I'd to try to adapt it and things like that but this is this is really not a perfect solution there's other solutions so plat ml was recently acquired by Intel and they have a lot of really cool compiler technology that is kind of in their little space TVM is a really exciting project also building on halide pulling together with its own secret sauce of different things and it's not just the compiler technology it's also in each of these cases they've built some kind of domain-specific language to make it easier for you the data scientist to write what you want in in a quick and easy way right and so and and often and what happens here is that each of these plug into the deep learning frameworks in different ways right and so what you end up having to do is you end up in a mode of saying TVM is really good for this set of stuff and tensor comprehensions which is another cool research project is good at these kinds of things and so I have to pick and choose the framework I want to use based on which one they happen to build into which is not very and again we don't take this from practical deep learning for coders because it's not practical yet you know these things are generally research quality code they generally don't integrate with things like PI torch they generally require lots of complex build steps the compile time is often really slow the the they work really great on the the paper but they kind of fall apart on things that aren't all those kinds of problems so our our goal and our vision here with with tensorflow but with Swiffer tensorflow also is to to make it so that you can express things at the highest level abstraction you can so if you if you have a bachelor arm layer totally go for that bachelor arm layer if that's what you want use it and you're good if you want to implement your own running bachelor arm you can do that in terms of mammals and and ads and things like that fine if you want to sink down further you can go down to one of these systems if you want to go down farther you could write assembly code for your accelerator if that's if that's the thing you're into you should be able to get all the way down and pick that level of abstraction that allows you to do what you want to do and so I I just want to give penser comprehension this is one random example of how cool this can be so this is taken straight out of their paper this is not integrated but tensor comprehensions gives you what is basically like Einstein notation on total steroids it's like fine yes good point it's like eins um and but taken to a crazy extreme level and what tensor comprehensions is doing is you write this very simple this very simple code it's admittedly kind of weird and it has magic and the syntax isn't the important thing but you write pretty simple code and then it does all this really hardcore compiler stuff so it starts out with your code it then fuses the different loops because these two things expand out two loops it does inference on what are the ranges for all the loops and what the the variables that you're indexing into the arrays do then fuse and tile these things fuse tile then sync the code like make us so the inner loops can be vectorized this is this is actually a particularly interesting example because this thing cared gem is a generalized matrix matrix product this is actually like the thing on which large amounts of deep learning in linear algebra and stuff is based on so like a lot of the stuff we write ends up calling a gem and the fact that you can write this thing in two lines of code if you like look inside like most linear algebra libraries there will be hundreds or thousands of lines of code to implement something like this so the fact that you can do this so concisely is super cool and so the idea that that we could do like you know nice little tweaks on convolutions or whatever in similar amounts of code is something that I'm I get very excited about yeah me too and the the the other thing to consider with this is that again generating really good code for this is hard but once you make it so that you separate out the code that gets compiled from the outlet of them's that get applied to it now you can do search over those algorithms now you can apply machine learning to the compiler itself and now you can do some really cool things that open up new doors so I mean that's actually really interesting because in the world of databases which is lot more mature than the world of deep learning this is how it works right you have a DSL normally called SQL we express what you want not how to get there and then there's a thing called a query analyzer or query compiler or query optimizer that figures out the best way to get there and it'll do crazy stuff like genetic algorithms and all kinds of heuristics and so like what we're seeing here is will we'll be able to do that for deep learning you know where our own dear cells and our own optimizers not deep learning optimizers but more like yeah optimizers yeah so it's gonna be really saying so we're building all this the MOR part of this is longer time horizon this is not going to be done by the time this video comes out but this is all stuff that's getting built and it's all open source since it's super exciting so overall summarize all this tentacle infrastructure stuff so test flow is deeply investing in the fundamental parts of the system this includes the compiler stuff also the run time off dispatch the kernels themselves there's tons and tons of tons of stuff and it's all super exciting so let's stop talking about the future yeah I mean that's kind of boring like what can you do today yeah this is very exciting Chris that you know sometime in the next year or two there'll be these really fast things but I actually know about some really fast languages right now really yeah they're called C C++ and you're saved oh yeah let me show you what I mean okay these are actually languages that we can make run really fast right now and it's quite amazing actually how how how easy we can make this like when you say to an average data scientist hey you can now integrate C libraries the response is not likely to be so awesome right because late scientists don't generally work at the level of C libraries but data scientists it you know work in some domain right you work in your neuroradiology image acquisition or you work in astrophysics or whatever and in your domain there will be many C libraries that do the exact thing that you want to do at great speed right and and currently you can only access the ones that have been wrapped in Python and you can only access the bits that have been wrapped in Python what if you could actually access the entire world of software that's been written in C which is what most software that's been written in and and it's easy enough that you know an average data scientist can do it so here's here's what it looks like right let's say we want to do audio processing okay and so for audio processing I'm thinking like oh how do I start doing audio processing and in my quick look around I couldn't see much in Swift that works on Linux for audio processing so you write out mp3 decoder from scratch yeah I thought about doing an mp3 decoders from scratch but they're nice a signal processing I figured like people have mp3 decoders already what are they doing and I'd open up on the Internet it turns out there's lots of C libraries that do it and one popular one apparently is called sucks right and I'm a data scientist and not an audio processing person so this is my process last week was like see library mp3 decode and it says you sucks so look at this I've got something here that says import sucks and then it says in it sucks and that it says read Sox audio where did this come from well this comes from a library here it is sound exchange this is what see library home pages tend to look like there tend to be very 90s and basically I looked at the documentation and say library documentation tends to be less than obvious to kind of see what's going on but you know kind of have to learn to read it just like you learn to replace on documentation and so basically it says you have to use this header and then these are the various functions you can call it something called inertia there's something called open so here's what I did I jumped into I jumped into vim and I created a directory and I called it Swift sucks and in that directory I created a few things I created a file called package Swift and this is the thing that defines a Swift package a Swift package is something that you can import and you can actually type Swift package in it and it'll kind of create the skeleton for you personally my approach to wrapping and you see library is to always copy an existing sea library folder that I created and then just change the name because every one of them has the same three files right so this is far number one you have to give it a name and then you have to say what's the name of the library in C and in socks the name of the library is sucks step two is you have to create a file called sources socks module dot module map and eccrine contains always these exact lines of code again readers change the word socks and the word socks and the word socks so it's not rocket science so what this is doing is this is saying that you want to call it socks in Swift they called it sucks you dodged for some reason well I actually put it substitute on h/h we'll see in a moment and then let the library is in that it gets linked in by lib socks yeah so all these things in C can be different yeah so you know most the time we can make them look the same yep and so then the final third file that you have to create is the H file and so you put that in sources sucks and I call it socks umbrella header H and that contains one line of code which is the header file which as you saw from the documentation you just copy and paste it from there so once you add these three files you can then do that okay and so now I can import socks and now this thing this C function is available to Swift right and so this is kind of wild right because suddenly like a lot of what this impractical deep learning for coders course is about is like opening doors that weren't available to us is data scientists before and thinking what happens if you go through that door right so what happens if you go through the door where suddenly all of the world C libraries are available to you what what can you do in your domain that nobody was doing before because they there wasn't any Python libraries like that so I I and so much I tend to do is write little Swift functions that rap to C functions to make them look nice so here's in it socks which checks for the value I'm told the docs say to check for and socks open read for some reason you've passed Neil Neil Neil so I just wrapped that and so now I can say read socks audio and so that's going to return some kind of structure and so you have to read the documentation to find out what it is or copy and paste somebody else's code very often the thing that's returned to you is going to be a C pointer and that's no problem Swift is perfectly happy with pointers you just say point e to grab the thing that it's pointing at and according to the documentation there's going to be something called signal which is going to contain things like sample rate precision channels and length and so I can get some those two so I can run that and I can see I've opened an audio file with the same library without any extra stuff so one of one of the things you can do is you can type Sox tab and you know here's all the stuff that's coming in from that header file that's well yeah super cool so so now I can go ahead and read that and this is kind of somewhat similar to pipe it in Python you can open C libraries in theory and work with them but I don't do it because almost never do it because I find when I try to the thing you get back are these sea structures and pointers which I can't work with in Python in a convenient way or if I do use things like PI bi and 11 which is something that helps with that then I have to create all these make scripts and compile processes and I just don't bother right one of us bother but in Swift it's totally fine and then the nice thing is we can bring Python and sweet C and Swift together by typing import Python the unholy marriage yeah now we can just say we can take our C array and say make numpy array and put it right so we're really bringing it all together now and we can even use the ipython display and we can hear some audio this hi everyone hi Chris Thank You Jeremy all right so why did I say yes to this again okay so this is pretty great right we've got we've got Swift libraries C libraries Python libraries we can bring them all together we can do stuff that our peers aren't doing yet but I want what I want to know Chris is how the hell is this even possible ah okay your guy that likes to look under the covers under the hood cool so let's talk about this seems really a very simple language so it should be no problem to do this right so C is two things actually it's really important I think you're just talking about why it's actually a very useful there's tons of code available and see a lot of that C is really useful but C's actually a terrible crazy gross language on its own right C has all these horrible things in it like pointers that are horribly unsafe and we have a question oh let's throw it is it possible to achieve similar results in Python using something like scythe on yeah absolutely so psiphon is a Python like language which compiles to see and I would generally rather write psyphon than see for integrating C with Python you're still kind of it's actually easier in a jupiter notebook because you can just say for sam percent safe on and kind of integrate it but as soon as you want to start shipping a module with that thing which presumably is the purposes you want to share it you didn't have to deal with let field scripts and stuff like that so like siphon has done an amazing job of kind of making it as it's easy as possible but I personally have tried to do quite a lot with scythe on in the last few months and ended up swearing off it because it's it's just still not convenient enough I can't quite use a normal deep bugger and a normal profiler and just ship the code directly and it's still yeah it's it's it's it's great for Python if that's what you're working with but it's nowhere near as convenient for it like I've created Swift C libraries I created a swift C library within a week of starting to use Swift it was just very natural cool and so the thing I want to underscore here's the C's actually really complicated so you has macros it's got this preprocessor thing going on it's get fields and unions in this weird notion of what verbs are it's got volatile it's got all this crazy stuff that the grammar is context-sensitive and gross and so it's just actually really hard to deal with you sound like somebody who's been through the process of writing a say compiler and came out the other side well so the only thing worse than C is C++ and has this like dual side of it it's both more gross and huge and it's also more important in some ways and so so if doesn't integrate with C++ today but we want to be able to we want to be able to provide the same level of integration that you just saw with C and C++ but how are we gonna do that well so if loves C plus C API is like Jeremy was just saying and so we love C API is because we want you to be able to directly access all this cool functionality that exists in the world and so the way it works as you just saw is we take the C ideas and remap them into swift and so because of that because they're native pure Swift things that's where you get the debugger integration that's where you get code complete that's where you get all the things you expect to work on swift talking to dusty deck old grody C code from the 80s or wherever you got it from whatever epoch and so and we also don't want to have rappers or overhead because that that's totally not what's about so Jeremy showed you that usually when you import the capi in a swift it looks like a capi and so you could but the nice thing about that is that you can build the api's you want to wrap it and you can build your abstractions and make that all good and Swift so one of the ways this happens is inside the Swift compiler it can actually read see header files and so we don't have a great way to plug this into workbooks quite yet but so it could actually take a C header file like math let H which has macros here's m underbar e because m underbar is a good way to name a apparently here's the old school square root here's the sign Coast function which you know of course it returns sine and cosine and through pointers because C doesn't have two poles and so when you import all that stuff into C and into Swift you get M underbar e as a double that get you can get you had square root and you can totally call square you have sine Coast you get this unsaved mutable pointer a double thing which we'll talk about later similarly like malloc free realloc all this stuff exists and so just to show you how crazy this is let's see if we can do the side-by-side thing can you make it do side-by-side yes my window skills are dusty check it out okay beautiful so what we have here is we have the original header file math dot H on the left and if you look at this you'll see lots of horrible things and see that everybody forgets about because you never write C like this but this is what C looks like when you're talking about libraries so we've got a whole bunch of if deafs we've got macros we've got like crazy macros we've got conditionally enabled things we've got these things are also macros we've got inline functions we've got tons and tons of tons of stuff we've got comments we've got structures like exception of course that's an exception right so when you import this into Swift this is what the Swift compiler sees you see something that looks very similar but this is all Swift syntax so you see you get the header the comments you get all the same functions you get all like here's your amount of our e and you get your your structures as well this all comes right in and this is why Swift can see it now how does this work that's the big magic question so if you want to get this work what you can do is you can build into the Swift compiler we can write a C parser right and we can implement C preprocessor and we can implement all the weird rules and see someday we can extend it and write C++ as well and we can build as this library so the Swift compiler knows how to parse C code and a C++ compiler is pretty easy to write so we can hack that on the weekend or yeah good news like we've already done this many years ago it's called clang so what clang is is it's a C++ compiler oh this is this is getting even just to even more talk about how horrible C is you you actually get you get inline functions inline functions the the the insane thing about inline functions is that they don't exist anywhere in a program unless you use them right they get in lined and so if you want to be able to call this function from C you actually have to code gen you have to be able to parse that code gen understand what unions are now understand all of this crazy stuff just so you can get the sign bit out of a float see also has things like function pointers and macros and tons of other stuff that's just it's just madness and so the right way to do this is to build a C compiler and the C compiler we have is called clang and so what ends up happening is that when Jeremy says imports ox Swift goes and says haha what's a Sox oh it's it's a module okay what is the module oh it's C oh it's got a header file fire up clang go parse the header file go parse all the things the header file pulls in that's what an umbrella header is and go pull the entire universe of C together into that module and then build what's called syntax trees to represent all the see stuff well now we've got a very perfect pristine sea view of the world the exact same way a c compiler does and so what we can do then is we can build this integration between clang in between swift where when you say give me malloc or give me socks in it it Swift says whoa what is that hey clang do you know what this is and clang says oh yeah I know what socks and it is it's this weird function it takes always pointers and Lulla and so says okay cool I will remap your pointers into my unsafe pointer I will remap your int into my in 32 because the languages are a little bit different and so that remapping happens and then when you call that inline function so if doesn't want to know how unions work that's crazy so what it doesn't set is it says hey clang you know how to do all this stuff you know how to code generate all these things and they both talked to the LVM compiler that we were talking about last time and so they actually talk to each other they share the code clang does all that heavy lifting and now it's both correct and it just works two things we like and so these two things plug together really well and now Swift can talk directly to see api's it's very nice if you if you're if you want to geek out about this there's a whole talk it's like half hour an hour long talking about how all this stuff works at a lot a lot lower level we will at that link that a lesson notes yeah so let's jump back to your example because so the reason one of the reasons I'm really interested in this description Chris is that it's kind of all about one of the reasons I really wanted to work with you apart from the fact that you're very amusing and entertaining is that a museum laughs oh yeah absolutely is that this this idea of what you did with playing and and Swift is like the kind of stuff that we're going to be seeing is what's happened with like how differentiation is getting added to Swift and like this idea of like being able to pull on this entire compiler infrastructure as you'll see is actually going to allow us to do some similarly exciting and surprisingly amazing things in the in deep learning world and I'll say this is all simple now but actually getting these two massive dr. eachother was kind of heroic and it was getting Python integrated was comparatively easy because Python is super dynamic and C is not dynamic yeah and and one thing I'll say about C libraries is each time I come across the C library they many of them have used these weird edge case things Chris described in surprising ways and so I just wanted to point at a couple of pointers as to how you can deal with these weird edge cases so when I started looking at kind of how do I create my own version of TF data I need to be able to read JPEG files there to be able to image processing I was interested in trying this library called this and vips is a really interesting C library for for image processing and so I started looking at the bringing in the C library and so I started in exactly the way you've seen already so let's do that so you could you lined just like we have a swift socks into in the repo there's also a swift lips and we'll start will start seeing some pretty familiar things there's the there's the same package Swift that you've seen before but now it's got some extra lines will describe in a moment there's the sources vips module map with the exact three lines of code that you've seen before there's the sources vips some header I call it a different name in this case which has the one line of code which is connecting to the header after you've done that you can now import bits done but it turns out that the vips documentation says that they actually added the ability to handle optional positional arguments in C and C and so it turns out that you can do that in C even though it's not officially part of C by using something called Boggs which is basically in C you can say this the number of arguments that go here is kind of not defined ahead of time and you can use something I've never heard of before called a sentinel and basically you end up with stuff which looks like this you end up with stuff which looks like this where you basically say I want to do a resize and it has some arguments that are specified like horizontal scale and by default it makes the aspect ratio the same but if you want to also change the aspect ratio and have a vertical scale you literally write the string v scale and that says oh the next argument is the vertical scale and if you want to use some in different interpolation kernel you pass a word kernel you say there's some different interpolation kernel now this is tricky because for all the magic that Swift does do it doesn't currently know how to deal with fogs and sentinels it's just a it's an edge case of the sea world that Swift hasn't handled I think this might be the last edge case ok Jeremy has this amazing thing to find the breaking point of anything that's what I do yes but no problem right the trick is to provide a a header file where the things that Swift needs to call look like the things that they expect so in this case you can see I've actually written my own sea library right and so I added a sea library by literally just putting in two sources I just created another directory and in there I just dumped let's say header file right and here's the amazing thing as soon as I do that I can now add that sea library not precompiled but actual sea code I've just written to my package Swift and I can use that from Swift as well right and so that means that I can wrap the the vips weird varargs resize version with a non recent virus resize version where you always plus in vertical scale for instance and so now I can just go ahead and say VIPs mode image and then I can save its get and then I can pass that to Swift for tensor flow in order to display it through matplotlib now there's a really interesting thing here which is when you're working with C you have to deal with C memory management so Swift has this fantastic reference counting system which nearly always handles memory for you um every see library handles memory management differently so we're about to talk about open CV which actually has its own reference counting system believe it or not but most of the time the library will tell you hey this thing is going to allocate some memory you have to free it later right and so here's a really cool trick the the VIPs get function says say this memory you're going to have to free it later to free memory in C you use the free function because we can use C functions from Swift we can use the free function and I need to make sure that we call it when we're all done and there's a super cool thing in Swift called defer and the first says run this piece of code before you finish doing whatever we're doing which in this case would be before we exit from this function yeah so if you throw an exception if you return early like anything else it will make sure to run that yeah in this case it didn't probably didn't need to fur because there isn't like exceptions being thrown or lots of different return places but I just that's my habit is that if I need to clean up memory I just chuck it you know defer block Ronis that's one of three methods that I use so that's that so because I like finding the edges of things and then doing it anyway the next thing I looked at and this gives you a good sense of how much I hate TF data is as I was trying to do anything I could to avoid TF data and so I thought all right let's try open CV and for those of you that have been around fast AI for a while you'll remember open CV is what we used in faster 0.7 and I love to it because it was like insanely insanely fast it's it's fast reliable high quality code that covers a massive amount of computer vision it's kind of like it's what everybody uses if they can and much to my sadness we had to throw it out because it just it hates Python multiprocessing so much it cat creating weird race conditions and crashes and stalls like literally the same code on the same operating system on two different AWS servers that are meant to be the same spec would give different results so that was said so I was kind of hopeful maybe wait it'll work and Swift so we gave it a go and unfortunately since I last looked at it they threw away their C API and Hailey and then L C++ only and Chris just told you we can't use C++ from Swift but here's the good news you can disguise it so thrifty doesn't know that it's C++ and so the disguise needs to be AC header file that only contains C stuff right but what's in the C++ file behind the head of file can be anything can be anything at all pesco claim those pascal calling conversions and swift can call them i didn't know that pascal strings - so he's swift cv and so Swift cv has a very familiar-looking package dot Swift there contains the stuff that we used - and it contains a very familiar-looking open CV for module map now open CV actually has more than one library so we just have to list all the libraries it has a very familiar-looking actually we don't even have a oh sorry that's right so we didn't use the header file here because we're actually going to do it all from our own custom C++ slash C code so I created a C open CV and inside here you'll find C++ code and we actually largely stole this from the go open CV wrapper because go also doesn't know how to talk to C++ but it doesn't know how to talk to C so that was a convenient way to kind of get started and you can see that for example we can't call new because new is C++ but we can create the function called map new that calls that and then we can create a header that has Marit near and that's not C++ right this is actually a plain C strat pointer to a struct and so I can call that and so even generics C++ generics we can handle this way so open CV actually has a full-on multi-dimensional generic array like none pay with like matrix multiplication or the stuff in it and the way it's generic stuff works is that you can ask for a particular pixel and you say what data type is it using C++ generics so we just create lots and lots of different versions for all the different generic versions which in the header file look like C so once we've done all that we can then say import Swift CV and start using open CV stuff so what does that look like well now that we can use that we can grab this we can read an image we can have a look at its size we can get the underlying C pointer and we can start doing yeah and we can start doing timing things and kind of see is it actually looking like it's going to be hopeful in terms of performance and so forth I was very scared when I started seeing in Swift all these unsafe and beautiful pointers and whatnot they're designed to make you scared there it starts up unsafe Canada but this is C right and so C C is inherently unsafe yeah theory on that is that it does not prevent you from using it it just makes it so you know that you're in that world but there's actually this great table I saw from Ray Wendell dicks from Ray Wendell Nick's website and I've stolen it here and basically what he pointed out is the names of all of these crazy pointer types actually have this very well structured thing they all start with unsafe they all end with pointer and in the middle there's this little mini language which is can you change them or not are they typed or not do we know the count of the number of things in there or not and what type of thing do they point to if they're typed so once you kind of realize all of these names have that structure suddenly things start seeming more reasonable again we have two questions all right let's start with the two questions Oh one is are the C libraries dynamically linked or statically linked or compiled from source to be available in Swift sure by default if you import them they are statically linked and so they'll link in with the normal linker flags and if the library is a dot a file then it will get stacked we like to direct later so if code if it's a dot SOF file then you'll dynamically link it but it's still linked to your executable all the linker stuff so deal open is a C API and so if you want to you can dynamically load C libraries you can look up their symbols dynamically you can do all that kind of stuff too another question is how much C do you have to know to do all these see related imports almost none so like I don't really know any C at all so I kind of like randomly press buttons until things start working or copy and paste other people C code yeah the internet sakura flow has a lot of helpful stuff yeah you need to know there's a thing called a header file and that contains a list of the functions that you can call and you need to know that you type hash include' angle brackets header file but you could just copy and paste the the swift socks libraries that I've already shown you which has the three files already there and so really don't need to know any C you just need to replace the word socks with the name of the library you're using and then you need to know you need to kind of work through the the documentation that's in C and that's the bit where it gets like you know I find the tab completion stuff is the best way to handle that is like hit tab and you you say let X equal and then you call some function and then you say X dot and you see what's inside it and yeah things kind of stuff and for all the hard time you give socks a you know not not a web design firm it has a pretty well structured API and so if you have a well structured API like this then using it it's pretty straightforward if you have something somebody hacked together they didn't think about it then it's probably gonna be weird you may have to understand their API and it may require you to understand a lot of C but those are the api's you probably won't end up using because if they haven't done a lot of love for their API people aren't using it usually my impression is that almost all of the examples of the future power of swift seem to rely on not on the abstraction to higher levels but on the diving into lower level details as a data scientist I try to avoid doing this I only go low if I know there's a big performance gain to be had so let me you know say my perspective as a data scientist and you know maybe we can hear you well and I was just gonna inject we're starting at the bottom so we'll be getting much higher level soon yeah but I mean there's a reason that I'm I'm wanting to teach this stuff which is that I actually think as data scientists this is our opportunity to be far more awesome it's like being able to access like something I've noticed for the last 25 years is like everybody I know in I mean it didn't used to be called data science but we used to call it like industrial mathematics or whatever operated within the world that was accessible to them right so like at the moment for example there's a huge world or something called sparse convolutions that are I know they're amazing I've seen like competition winning solutions they they like get stated the out results it's like two people in the world doing it because it all requires custom CUDA kernels you know for four years for decades almost nobody was doing differential programming because we had to calculate the derivatives by hand so like it's it's not just about oh I want a mixture is absolutely not about I want an extra 5% of performance that's about being able to do whatever's in your head like I used to be a management consultant I'm afraid to say and I didn't know how to program and I knew Excel and the day that I learnt Visual Basic was like oh now I'm not limited to the things I can do in a spreadsheet I can program you know and then when I learned Delphi it was like oh well now I'm not limited to the things that I can program in a spreadsheet I can do things that are in my head so that's that's where I want us all to get to yeah hey I know some people are feeling overwhelmed with Swift C C++ Python customers tensorflow Swift for tensorflow do we need to become experts on all these different languages no no we don't but could I show why this is like super interesting because this is like this dislike so let me show you why I started going down this path right which is that I was using TF data and I found that it took me thirty three seconds to iterate through imagine it and I know that in in Python we have a notebook which server created to compare called timing and the exact same thing takes eleven point five seconds and like this is not an insignificant difference waiting more than three times as long just to load the data is just not okay for me so I just thought well I bet OpenCV can do it fast so I created this little OpenCV thing and then I created a little test program so this is the entirety of my test program right which is something that downloads imagenet and reads and resizes images and does it with four threads and so if you go Swift run sorry Swift okay so when I run this check this out 7.2 seconds right and so this was like half a day's work and half a day's work I have something that can give me an image processing pipeline that's even faster than pi torch and so it's not it's it's not just like oh we can now do things a bit faster but it's now like any time I get stuck that I can't do something it's not in the library I want or it's it's so slow as to be unusable you know this what whole worlds open so I'd say like we don't really touch this stuff and until you get to a point where you have no choice but to and at that point you're just really glad it's there well in to me I think it's also the capability is important even if you don't do it so keep in mind this is all code that's in a workbook so you can get code in the workbook from anywhere and now you can share that workbook you don't have to share this like tangled web of dependencies that have to go with the workbook and so the fact that you can do this in Swift doesn't mean that you yourself have to write the code but it means you can build on code the other people wrote and if you haven't seen Swift it off this is your first exposure to it this is definitely not the place you start like the data API is and we're about to look at would be a much more reasonable place to start you've had a month or two months worth of hacking with Swift time and that's Jeremy months so that's like a year for normal people so this like this being like super powerful and the ability to do this is I think really great and I agree with you yeah and I am totally not a C programmer at all and it's honestly it's been more like two weeks because before that I was actually teaching a Python course believe it or not but silver has been doing this for a month yeah yeah so so I mean so this is all it's all there and I would definitely recommend ignoring all of this stuff and we're about to start assuming up the levels of the stack but the fact that it's there I think is reassuring because one of the challenges that we have with Python is that you get this ceiling and if you get up to the ceiling then there's no going further without this crazy amount of complexity and whether that be concurrency or whether that be AC api's or whether that the other things that that prevents the next steps in the next levels of innovation and the industry moving forward and this is meant to be giving you enough to go on with until a year's time of course as well so like exactly like it's hopefully this is something where you can pick and choose which bits you want to dig into and whichever bit you picked it again - we're showing you all the depths that you can begin to over the next 12 months so I was really excited to discover that we can use open CV which is something I've wanted ever since we had to throw it away from first AI and so I thought you know what would it take to create a data blocks API with open CV and thanks to Alexis Gallagher who kind of gave us the great starting point to say well here is what a swift key style data blocks would look like we were able to flesh it out into this complete thing and when Chris described Alexis to me as the world leader on value types I was like wait that's what you created them I thought okay I guess we can listen to Alexis's code this I will say I'm terrified about presenting those slides because alexis is sitting right there and if you start scowling then we have a handheld mic coming correct as anytime so there's a thing here called OC data block generic where you'll find that what we've actually done is we've got the entire data blocks API in this really interesting swiftie style and what you'll see is that when we compare it to the Python version this is on every axis very significantly better so let's talk about some of the problems with the data block API in Python I love the data block API but lots of you have rightly complained that we have to run all the dot blah blah blah de blah in a particular order if we get the wrong order we get inscrutable errors we have to make sure that we have certain steps in there if we miss a step we get inscrutable errors it's it's difficult to deal with at that and then the code inside the data blocks API I hate changing it now because I find it too confusing to remember like why it all fits together let me check out this swift code that does the same thing right so is that don't load this is just the same get files we've seen before all we need to do is we say you know what if you're going to create some new data bunch you need some way to get the data you some need some way and let's assume that that is paths for now it needs some way to turn all of those paths into items so something like our item list in Python you need some way to split it between training and validation and you need some way to label the items right so for example for image net download calls that and things that convert paths to images so which convert which grab all of the list of paths is that collect files and then the thing that converts that decides whether they're training or validation is whether the parent or parent is trained or not and the thing that creates the label is the parent and so like we can basically just define this one neat little package of information and and we're done and Swift will actually tell us if we forgot something or if one of the things what we provided like his training is meant to return true or false if it's training or validation if we return like accidentally returned the words trained instead it'll complain and let us know so like it I just love this so much about to understand what's going on here we need to learn a bit more about how swift works and this idea of protocols yeah so this is something that is actually useful if you are doing deep learning stuff so let's talk about okay go for it let's talk about what protocols are in Swift so we've seen Struck's we will see classes later but right now we want to talk about what protocols are and if you've worked in other languages you may be familiar with things like interfaces and java abstract classes or often use advanced other weird languages have things called type classes and so all these things are related to protocols and Swift and what protocols do is they're all about splitting the interface of a type from the implementation and so we'll talk about layer later layer is a protocol and it says that to use a layer to define rather to define a layer you have this call so layers are callable just like in pi torch and so then you can define a dense layer and say how to call a dense layer you can define a comp to D and show how to implement a conductivity layer and so there's a contract here between what a type is supposed to have all layers must be callable and then the implementations these are different right so this is pretty straightforward even that's quite nice track it's like in PI torch you kind of have to know that there's something called forward and if you misspelled it or forget it to put it there or put dunder call instead of forward you get kind of weird inscrutable arrows where else with this approach you get time completion for the the signature yeah and Sam Swift will tell you if you get it wrong it'll say this is what the function should have been called yeah that's great and so what this is really doing is this is defining behaviors for groups of types and so we're saying a layer layer is a is like the commonality between a whole group of types that have behaved like layer and what is that behavior mean well it's a list of what are called requirements and so these are all the methods that the type has to have this is the signatures of the types and these things often have invariance and so one of the things that Swift has in its library is the notion of equatable what is equatable well in equatable is any type that has this equals equals operator right and then it has says what is it quite ability all that kind of stuff now the cool thing about this is that you can build up towers of types and so you can say well equatable it gets refined by an additive arithmetic and an additive arithmetic is selling the sports additional sub direction that if you also have multiplication you can be numeric and if you also have negation then you can be signed and then you can have integers and you can have floating point and now you can have all these different things that exist in the ecosystem of your program and you can describe them and so this is all very this these things these ways to reason about these groups of types give you the ability the ability to get these abstractions that we all want and these types already existence where these all exists and you can go see them in the sand library and so why do you want this well the cool thing about this is that now you can define behavior that applies to all of the members of that class and so what we're doing here is we're saying not equal well all things that are equatable and this t : equatable says i work with any type that is equatable what this is doing this is defining a function not equal on any type that's equatable and it takes two of these things and returns a bool and we can implement not equal by just calling equals equals which all equatable things are and then inverting it so to be clear what chris just did here was he wrote one function that is now going to add behavior to every single thing that defines equals automatically which is yep pretty magic just like everywhere boom one place super super abstract but this also works or lots of other things this works for like absolute value what does that so value mean it well it needs any type that is signed and numeric and that's comparable and how do you implement absolute value well you compare the thing against zero if it's lessons or you negate it otherwise your turn it like super simple but now everything that is a number that can be compared is now absol types same thing all these things work the same way and so with dictionary what you want is you want the keys in a dictionary all have to be hashable this is how the dictionary does its efficient lookups and things like that the value can be anything and so all these things kind of stack together and fit together like building blocks one of the really cool things about this now is that we could start taking this further so we talked about not equal bill and have equally in the last lesson we defined this is odd function we define it on int well because this protocol exists we can actually add it as a method to all things that are binary integers and so we can say hey put this on all binary integers and give them all in it is odd method and now I don't have to put is odd on int + int 16 and then 32 and the C weird things and you could just do it in one place and now everybody gets this method right on layers right this is something that's closer to home here we can say hey I want a inferring from method that does some learning phase switching magic nonsense but now because I put this on all layers well I can use it on my model because your model is a layer my dense layer that's a layer and so this thing allows this one simple idea of defining groups of types and then broadcasting behavior and functionality on to all the once is really powerful yeah I mean it's it's like pythons monkey-patching which we use all the time but a it's it's not this kind of hacky thing with weird undefined behavior sometime and B we don't have to monkey patch lots and lots of different places to add functionality to lots of things we just put it in one place and the functionality gets sucked in by everything that can use it yeah and remember extensions are really cool because they work even if you didn't define the type and so what you can literally do is you can pull in some C library not the wheel of C but some C library and add things to its trucks I mean this is it won't have things automatically added to those tracks absolutely already supports those operations yeah so so like all the stuff composes together in a really nice way which allows you to do very powerful and very simple and beautiful things so mix-ins show up and you can control where they go and so here's an example this is something with Jeremy wrote and so he defined his own protocol accountable and he says things are accountable if they have a variable named count and the only thing I care about for accountable things is I can read it I don't have to write it that's what the get means and so he says arrays accountable his OpenCV Matt thingy is countable like all these pixels with it yep yeah all these things are accountable and then Jeremy says hey well take any sequence let's add a method or a property called total count to anything with the sequence a sequence is the same as pythons iterables what I think you can hit it right through exactly and so this is things like dictionaries and arrays and ranges and like all these things are sequences and it says so long as the element is countable so I have an array of countable things then I can get a total count method or a property right and the way this is implemented is it just says hey map over myself get the count add all the counts up together and then I have a total count of all the things in my array and now if I have an array of arrays an array of maths of lazy map collection sequency thingy of mats whatever it is now I can just ask for its count or its total count at Chris this um so this functionality you're describing is basically the same as what Pascal calls type classes yes is that right yeah so this is this kind of like stolen from a school's borrowed I mean so the interesting thing for me here you let them play with it too well if we think the reason I ask is cause like I've tried to use high school before many times and have always failed I'm clearly not somebody who's smart enough to use Pascal yet I wrote the code that's on the screen right now like a couple of days ago and I didn't spend a moment even thinking about the fact I was writing the code it was only like the next day that I looked back at this code and I thought like wow I just did something which no other language I've used both could do and I was mad enough to do it like it kind of makes this what I think of is like super genius functionality available to normal people yeah and so so back at the very very beginning this we talked about Swift schools to be able to take good ideas wherever they are and assemble them in a tasteful way and then be not weird being not weird is a pretty hard but important goal so there the way I look at programming languages is the programming languages in the world have these gems in them and Haskell has a lot of gems incidentally it's a really cool functional language it's very academic it's it's super powerful in lots of ways but then it gets buried in weird syntax and it's this purely functional you have to be you know has a very opinionated worldview of how you were supposed to write code and so it appeals to a group people which is great but then it gets ignored by the masses and to me that's really sad that's the great technology and programming languages that's been invented for decades and decades and decades gets forgotten just because it happened to be put in the wrong place yes even the whole way things are described you're all about yes MA noise and monads and whatever its essentials and things I think yeah exactly and so a lot of what Swift is trying to do is it's trying to take those ideas re-explain the MoMA way that actually makes sense stack them up in a very nice consistent way and design it right and so a lot of this was pull these things together and really polish and really push and like make sure that the core is really solid we have a question how does the swift protocol approach avoid the inheritance tree hell problem in languages like C sharp where you end up with enormous trees that are impossible to refactor yes and similarly what are the top opinions around using the mixin pattern which has been found to be an anti pattern in other contexts yeah so the way that Swift influences is completely different than the way that subclasses work in c-sharp or other or java or other object oriented languages they're what you get is something called a v table and so your type has to have one set of mappings for all these different methods and then you get very deep inheritance hierarchies and Swift you end up adding methods to int like so we on the left side added a method is odd to all the integers integers don't have a VT well that would be very inefficient thing to do and so the implementation is completely different the traits are completely different I will at the end of this I think in a couple of slides have a good pointer that will give you a very nice deep dive on all that kind of stuff so also there's the binary method problem and there's a whole bunch of other things that are very cleanly solved in Swift protocols and then there was also a question out of out of curiosity could you give an estimate of how long it would take someone to go from a fair level of knowledge in Python tensorflow deep learning to start being able to be a competent contributor to Swift for tensorflow yeah so we design Swift in general to be really easy to learn and so that you can learn as you go and this course is a little bit very it's very bottoms up but a lot of Swift just like Python was designed to be T top and what you start with when you when you go and from that perspective as you get a very top-down kind of perspective and what I would do is I would start with the Google for a swift tour and you get a very nice top-down view of the language and it's it's very approachable and like just pick something that like is in fast AI in some fast AI notebook now we haven't implemented it yet and pop it into a notebook right and the first time you try to do that you'll get all kinds of weird errors and abstractions and you won't know what's going on but after we perform and that's what the communities about yeah lots of help from the forum and Chris and I are both on the forum the CTF teams on the forum will help you out and in a few weeks time you'll be writing stuff from scratch and finding it a much smoother process yeah so I want to address one weird thing here and give you something to think about and you might wonder ok well Jeremy wants to know all the countable things we have arrays and we have Matt and we have to say that they are accountable but the compiler knows that it's accountable or not like if you try to make something countable it doesn't have a count method the compiler will claim complain to you so why do we have to do this well let's talk about a different example and the answer is that protocols are not just about methods this is also related to the c-sharp question but the behavior of those methods also matters and so here we're going to switch demands and talk about shapes and so I have shape all shapes have to have a draw method all right this is super easy and what I can do is I can define an octagon and tell it how to draw I can define a diamond try tell it how to draw using exactly the same stuff that we just saw before really easy and the cool thing about this is now I can define a method refresh and now refresh all it does is it clears the canvas and draws the shape and so all shapes will get a refresh method and so if you go do a tab completion on your octagon it all just works but what happens if you have something else with the draw method so Cowboys know how to draw it's a very different notion of what drawing is right we don't want Cowboys to have a refresh method it doesn't make sense to clear the screen and then pull out a gun and that's that's that's not what we're talking about here and so the the idea of protocols is really again to categorize and describe groups of types and one of the things you'll see which is kind of cool is you can define a protocol with nothing in it so it's a protocol that doesn't require anything and then you go say I want that type that type that type that type to be in this group and now I will have a way to describe that group of types so it can be totally random whatever makes sense for you and then you could do reflection on you can do lots of different things that now applied it exactly that group of ten and I actually found I still find um that this kind of protocol based programming approach it's like the exact upside down opposite of hell I've always thought about things it's kind of like you don't create something that contains these things but you kind of like that it all somehow shove things in and the more I've looked at code that works this way the more I realize it it tends to be clearer and more concise and but I still find it a struggle because I just don't have that that sense if this is this is how to go about creating these kinds of api's and one of the things you'll notice is that we added this protocol to array in an extension right so unlike interfaces in a java or c type c-sharp type of language we can take somebody else's type and then make it work with the protocol after the fact and so I think that's that's a superpower that allows you to work with work with these values in different ways so this is a super brief high level view of protocols protocols are really cool and Swift and they drawn a lot of great work in the high school in other communities there's a bunch of talks and even even Jeremy wrote a blog post it's really cool that talks about some of the fun things you can do one extensions make code hard to read because once a functionality of a particular API or class is extended in this way you won't know if the functionality is coming from the original class or from somewhere else yeah so that's something you let go of when you write swift code and there's there's a couple of reasons for that one of which is that you get good ID support and so again we're kind of building some parts this airplane as we fly it but in Xcode for example you can click on a method and jump to the definition right and so you can say well okay here's a weird here's map Honore where does map come from well map isn't defined on an array map filter reduced those aren't defined on an array those are actually defined on sequence and so all sequences have map filter reduce and a whole bunch of other stuff and so arrays are of course sequences and so they get all that behavior and so the fact that it's coming out of sequence as a swift programmer particular when you're starting it doesn't really matter actually you know reality we've had this same discussion around Python which is like Oh Jeremy import star and therefore I don't know where things come from because the only way I used to know where things come from is because I looked at the top of the file and it would say from blah import foo and so I know foo comes from blah and we had that whole discussion earlier lesson where I said that's not how you figure out where things come from you learn to use jump to symbol in your IDE or you learn to use Jupiter notebooks ability to show you where things come from that's that's that's just the way to go thank you and I feel that Scala is often a very nicely designed language that my knowledge doesn't lack in terms of the features I've seen so far and Swift is that true and if so is the choice of Swift more about JVM as opposed to non JVM runtimes and compilers yeah so skull is a great language Scala is one of the my the way we explain Scala is that they are very generous in the features they accept they're undergoing a big redesign of the language to kind of cut it down and try to make the features more sensible and stack up nicely together Swift and Scala have a lot of similarities in some places and they diverge wildly in other places I mean I would say there's a you know I feel like anybody during this course understands the value of tasteful curation because play torch is very tastefully curated and as a flow might not be and so like using it tastefully curated carefully put together API like Swift has and like play torch has I think it makes life easier for us as data scientists and programmers yeah but but I think the other point is also very good so Scala is very strong in the JVM a virtual machine ecosystem and works very well with all the Java API is and it's great in that space Swift is really great if you don't want to wait for a JVM to start up so you can run a script right and so there's there's nice duels and they have different strengths and weaknesses in the sentence we have time before our break that I can quickly show how this all goes together ok I probably can't stop you if I wanted to if so so just to just to come back to this 8c right you can basically see what's happened here we've defined this protocol saying these are the things that we want to have in a day to box API and then we said here is a specific example of a data box API now at this point we we are missing one important thing which we've never actually created the bit that says this is how you open an image and resize it and stuff like that right so we just go through and we can say let's call dot download what's called dot get items and we can create nice simple little functions now we don't have to create complex class hierarchies to say things like tell me about some sample and it prints it out right and we can create a single neural function which creates a train and a valid this is neat right this is something I really like about this style of programming is this is a named couple and I really like this idea that we don't have to create our unstrapped in class all the time it's kind of a very functional style of programming where you to say I'm just going to define my type as soon as I need it and this type is defined as being a thing with a train and a thing with a valid so as soon as I work brackets around parentheses around this it's both the type and a thing now and so now I can partition into trained and valid and that's return something where I can grab a random element from valid and a random element from train we can create a processor and again it's just a protocol right so remember a processor is a thing like the four categories creating a vocab of all of the possible categories and so a processor is something where there's some way to say like what is the vocab and if you have a vocab then process things from text into numbers or D process things from numbers into text and so we can now go ahead and create a category processor right so here's like grab all the unique values and here's labeled an int and here's inter label why are you using parentheses on your map Jerry there we go yeah so so now that we have a category processor we can try using it to make sure that it looks sensible and we can now label and process our data so we first have to call label and then we have to call process now given that we have to do those things in a row rather than creating whole new API functions we can actually just use function composition now in pi torch we've often used a thing called compose that actually it turns out to be much easier as you'll see if you don't create a function called compose but you actually create an operator and so here's an operator which we will call compose right which is just defined as first call this function f and then call this function G on whatever the first thing you passed it is so now we have to find a new function composition which first labels and then processes and so now here's something which does both and so we can map right so we don't have to create again all this all these classes and special-purpose functions we're just putting together function composition and map to label all of our training data and all of our validation data and so then finally we can say well this is the final structure we want we want a training set we want a validation set and let's again create our own little type in line right so that's an array of tuples yeah so our training sets an array of name tuples a validation set is an array of name tuples and so we're going to initialize it by passing both in and so this basically is now our data blocks API there's a function called make split labeled and we're just going to pass in one of those configuration protocols we saw so we're going to be passing in the imaginet configuration protocol the thing that conforms to that protocol and we're going to be passing in some processor right which is going to be a category processor and it's gonna call download get the items partition map label of and then initialize the processes State and then do label of and then process is our processing function and then map that right and so that's it so now we can say to use this for the opencv we define how to open an image there it is we define how to convert BGR to RGB because OpenCV uses BGR that's how old it is we define the thing that resizes 2 to 24 by 224 with bilinear interpolation and so the process of opening an image is to open then BG add RGB and then resize then we compose them all together and that's it all right so now now that we've got that we then need to convert it to a tensor so the entire process is to go through all those transforms and then convert to a tensor and then I'll skip over the bit that does the mini-batches there's a thing we've got to do the mini batches with that split label data we created and we then just pass you in the transforms that we want and we're done right so that the data blocks API in kind of functional ish protocol is Swift you know ends up being a lot less code to write and a lot easier for the end user because now for the end user there's a lot less they have to learn to use this data blocks API it's really just like to say the normal kind of maps and function composition that hopefully they are familiar with as 50 overs so I'm really excited to see how this came out because it solves the problems that I've been battling with for the last year with the Python data blocks API and it's been you know really at just a couple of days to work to get to this point and one of the one of the things at this point Stu and Swift that is a big focus is on building api's and so again we've been talking about this idea of being able to take an API use it without knowing how it works it could be in C or Python or whatever but it's about building these things that compose together and they fit together in very nice ways and with Swift you get these clean abstractions so once you pass in the right things it works you don't get the stack trace coming out in the middle of somebody else's library that now you have to figure out what you did somewhere along the way they caused it to break yes at least not nearly as off so to see what this ends up looking like I've created a package called data block it contains two files in it's got a packet a package but Swift and it's got a main dot Swift and main dot Swift is that right so all that in the end to actually use it that's how much code it is to use your data blocks API and grab all the batches so it comes out super pretty yeah so let's take a five-minute break and see you back here at 8:05 okay so we're we're gradually working we're way back to what we briefly we briefly saw last week notebook 11 training image net and we're gradually making our way back up to to hit that point again it's a bit of a slow process because along the way we've had to kind of invent float and learn about a new language and stuff like that but we are actually finally up to zero to a fully connected model believe it or not and the nice thing is at this point things are going to start looking more and more familiar one thing I will say though that can look at quite unfamiliar is the amount of typing that you have to type with Swift but there's actually a trick which is you don't have to type all these types you don't have to take types what you could actually do is you can say like oh you know here's the type I use all the time tense a bracket float and I don't like writing angle brackets either so let's press create a type alias called TF and now I just use TF everywhere a lot of real Swift programmers in their production code might not like doing that a lot I mean personally I do do that a lot even not in that books but you know you might want to be careful when you're if you're doing actual programming the way I would look at is if you're building something for somebody else to use if you're publishing an API you probably don't want to do that yeah but if you're hacking things together and you're playing and having fun it's no problem at all yeah I mean different strokes I I personally I would say if I'm giving somebody something that's the whole thing's tensor floats I would do it but anyway in a notebook I definitely don't want to be typing that so in a notebook make it easier for your interactive programming by knowing about things like type alias yeah that's something we also want to make better just in general so that these things all just default to float yeah that'll be nice so then we can write a normalized function that looks exactly the same as our Python normalized function and we can use mean and standard deviation just like in Python and we can define tests where the certs just like in Python so this all looks identical we can calculate N and M and see the same constant the variables that were used in Python in exactly the same way as Python we can create our weights and biases just like in Python except there's a nice kind of rule of thumb in the swift world which is anytime you have a function that that's going to create some new thing for you we always use the inert constructor for that so for example generating random numbers and dumping them into a tensor that's constructing a new tensor for you so it's actually you're actually calling tensorflow in it here and so if you're trying to find where is it in an API that I get to create something in this way you should generally look for the in the inert section so this is how you create random numbers in Swift or tensor flow that's how you create a tensor of zeroes and Swift for tensor flow so here's our weights and biases this is all the same stuff we just basically copied and pasted it from the PI Torche version with some very very minor changes create our linear function except rather than at where use dot because that's what they use in swift potential flow if you're on a Mac that's option eight if you're one anything else it's composed key dot equals and so now we can go ahead and calculate linear functions we can calculate value exactly the same as pi torch we can do proper climbing in it exactly like pi torch and so now we're at the point where we can define the forward path of a model and this looks basically again identical to pi torch a model can just be something that returns some value so that the forward paths of our model really just builds on stuff that we already know about it looks almost identical to pi torch as does a loss function right it looks a little bit different because it's not called squeeze it's called squeezing shape doesn't that mean squared error is the same as pi torch as well and so now here's our entire forward pass so hopefully that all looks very familiar if it doesn't go back to 0-2 in the Python notebooks and actually this is one of the tricks like this is why we've done it this way for you all is that we have like literally kind of these parallel texts you know there's the Python version there's a swift version so you can see how they translate and see exactly how the hell you can go from one language and one framework to another that's all very well but we also need to do a backward pass so to do a backward pass we can do it exactly the same way as again we did it in Pride watch one trick we kind of python hack we use and so the my talk and so this is doing it the hard way at all manually ok have to build it doing it all manually yep because we have to build everything in scratch and the pi torch version we actually added a dot grad attribute to all of our tensors you're not allowed to just throw attributes in arbitrary places in Swift so we have to define a class which has the actual value and the gradient but once we've done that the rest of this looks exactly the same as the pipe torch version did here's a MSC grad irelia grad that's all exactly the same in fact you can compare here right here's the Python version we created fill in grad here's a swift version fill in grad it's almost identical okay so now that we've done all that we can go ahead and do our entire forward and backward pass and we're good to go but it could be so much better well you skip past the big flashing red lights that says don't do this did you miss up her tell me about it okay so let's let's talk about this so this is defining a class and putting things in classes and we haven't seen classes yet at least not very much that's true because before we have to use things that looked like classes but they didn't say class on them they said strapped on them yes and so what is that and so so so let's let's play a little game and so let's talk about this idea of values and references because that's what us that's what structure sees class really means in Swift a value is a struct thing and a reference as a class thing let's talk about Python here's some really simple Python code and this is there's no tricks here what we're doing is we're assigning 4 into a we're copying a into B we're incrementing a and printing them out and so when you do this you see that it gets incremented of course B does not of course this all makes perfect sense and Swift you do the same thing you get the same thing out this is how math works right all very straightforward let's talk about arrays so here I have an array or list in Python and I put into X and then I copy x and y I add something to X and it has it this so and then it has the extra item that makes perfect sense right what happens to Y what what just happened here I just added something to X and now why change now you have what is going on here well we learn we learned that there's this thing called a reference and we learned that it does things like this and we learn when it bites us what happens in Swift well so if Desiree doesn't have lists the same way and so here we have again this identical code except var we put in 1 and a 2 into X we copy x and y we add something to X we print note we get the extra element but Y is correct what just happened so this is something called value and reference semantics and and Swift arrays dictionaries tensors like all these things have what's known as value semantics and let's dive in a little bit about what that is so a value in something that has value semantics is a variable that sorry this is self referential when you declare something in your code you're declaring name and if it's a name for a value that name stands for that value right X stands for the array of elements that it contains what this is how math always works this is what you expect out of basic integers this is what you expect out of basic things in the you interact with on a daily basis reference maps are weird if you think about it so what we're doing is we're saying that X is a name for something else and so we usually don't think about this until it comes around to bite us and so this is kind of a problem and let's dive in a little bit to understand why this causes problems so here's a function let's do thing it's something that Jeremy wrote with a very descriptive name and it takes T and then it goes and updates this and that's fine right it's super fast everything is good you move on and put in a workbook and then you build the next workbook next what calls in a new thing and you find out oh well it changed the tensor I passed in but I was using that tensor for something else and now I've got a problem because it's changing a tensor that I wanted to use and now I've got this bug I have to debug it and I find out the do thing that's causing the problem and so what do I do I go put a clone in there I don't know who here adds clones in a principled way or who is in a principled way so what we do in fast AI is we kind of don't have clone and then when stings not breaking I add add more until things stop raking and then we're done that sounds great yeah so there's a lot of clone in frost AI and yeah that's a good principle possibly a few too many a possibly a few two-shoes well so now think about this what we have is we have a foot gun here and the first case so something that's ready to explode if I use it wrong now I added clone and so good news it's correct but slow like so it's gonna do that copy even if I don't need to which is really sad and Swift things just work you pass an a tensor you can update it you can return it and it leaves the original one alone arguments in Swift actually even default to constants which makes it so that you can't do that if you do actually want to modify something in the caller you can do that too you just have to be a little bit more explicit about it and use this thing called in out and so now if you want to update the thing somebody passed to you that's fine just pass it and out and everything works fine and on the call side you pass it with this ampersand thing so that they know that it can change now what is going on here right so this this is good math is like the correct behavior but how does this work well we're talking about names we're talking about values and so here I have a struct this is a value a thing and so I had say it has two fields of real and imaginary and I define a an instance of my complex number here named X and so this is saying I have X and it's a name for the value that has one and two in it and so if I introduce y Y is another notational instance of this struct and so it also has a 102 and if I go and I copy it then I get another copy and if I change one that I update just wise this is again the way things should work and so this works us with structs this works with tuples this works with arrays and dictionaries and all that kind of stuff how do references work well references the name here here I have a class and the class has a string and has an integer and so somewhere in memory there is a string and there is an array and they're stuck together just like with the struct but now when I say X X is actually a reference or a pointer or the direction the reason of that is because you wrote class instead of struct so by writing class you're saying when you create one of these things please create a prince not a value yes that's exactly right and now what happens with references is you now get copies of that reference and so when I copy X into y just like in PI torch or Python I have another reference or another pointer to the same data and so that's why when you go and you update it so I'm going to go change the array through Y it's also gonna change the data that you see through X all right and so in Swift you have a choice and so you can declare things as classes and classes are good for certain things and and and they're important and valuable and you can subclass them and classes classes are nice and various ways but you have a choice and a lot of things that you've seen are all defined of structs because they have much more predictable behavior and they stack up more correctly so in this case you know I was trying to literally duplicate the Python /pi torch API and so I understand I wasn't able to unless I used class yes then you could have said okay well that's how you do it but yeah and we'll get back to autodefense exit but don't do it that way yeah and so you can absolutely do that and again when you're lying Swift it's fine just look for the things are familiar and then you can learn as you go that's perfectly acceptable but here we're trying we're trying to talk about things Swift is doing to help save you and make your code more efficient and things like that and ice ice I still reach for class a lot but then every time a real Swift programmer takes my thing that had class and replaces it with something more swifty it ends up being like shorter and easier to understand and so like it's III agree like go for it get things working with class but but when it comes time start to work with this and look at it and figure out how it works now there's one thing that's really weird if you remember last time the first thing I told you about was var and let write and what is going on here this does not make any sense we've got Y and now we are updating if this thing will go away we are updating a thing in why even though Y is a concept and and and what what does that even mean well the reason here is that the thing that is constant the thing is this constant is this reference and so we've made a new copy of the reference but we're allowed to copy the thing it points to because because we're not changing X or Y itself so this doesn't make sense none of this makes sense but but how does lettin var work well this is this is a thing that comes back to the mutation model in Swift I'll go through this pretty quickly this is not something you have to know but let's say I have a complex number and it's destruct and I say hey this thing is a constant I want to go change it right that's not supposed to work what happens well if you try to do that Swift will tell you how high you can't do that you can't use plus equals on a real that's in a C because C one is a let and Swift is helpful and so it tries to lead you to solving a problem that says hey by the way if you want to fix this you want to make a go away just change let to var and then everything is good that's totally fine now okay fine well what maybe I really do want to change it and so what I'm going to do is I'm gonna get a little bit trickier and I'm going to find this extension I'm gonna had a method increment to my complex number I'm gonna increment inside the method and then call the method can I get away with that well you know these things may be in different files the compiler may only be able to see one or the other and so if you run this it has no idea whether increment is going to change that thing right and so what the compiler does is says ah well you can't employ increment real inside of this increment method either because it says self is immutable and it says mark method mutating to make self mutable now the thing to think about in methods both in Python but also in Swift is that they have a self and in in Python you have to declare it Swift has it too it just it's just not making you writer all the time because I thought that would be annoying and so when you declare a method on a struct what you do is you're getting self and it's a copy of the struct okay now what this is saying is this is saying that hey you're actually changing self dot real self is constant and so you can't do that here but what you can do is you can mark it mutating and so what that looks like is that says we can mark this function of mutating and what that does is it says our self is now one of these and out things the amount thing that allows us to change it in the color and because it's not mutating it's totally fine to change it that's no big deal and the compiler leads you to this and shows you what to do but now we come back to this problem over here we say well we have a constant we're calling it Cremona how does that work well it still doesn't the compiler will tell you hey you can't do that you can't mutate c1 and now it knows the increment can't change it and so it says really really really if you want to do this go mark c1 as a var and Jeremy would say just mark everything is involved it is that's how he is and so the nice thing about this though is it all stacks up nicely and it all works and this is what allows this is kind of the underlying mechanics that allow the value the value stuff to work now you may be wondering how is it sufficient so we're talking about in the PI prefer world you end up copying all the time even if you don't end up needing it and Swift we don't want to do with all those copies and so on the other hand we don't want to be like always copying so where do the copies go and how does that work so if you're using a rays or arrays of arrays of arrays of dictionaries of raisin like super nested things what ends up happening is arrays a struct you might be surprised and inside of that struct it has a pointer or a reference and so the elements of an array are actually implemented with the class and so what I have here is I have a 1 which is some array and i copied it to a 2 and I copied a 3 I copy today 4 because I'm passing it all around I'm just passing this array around no big deal and what happens is I'm just copying this this reference and it happens to be buried inside of a struct and so this passing around arrays full value semantics super cheap no problem it's not copying a data it's just passing the pointer right just like you do in C or even in Python the magic happens when you go and you say ok well I've now got a 4 and so all these things are all sharing the same I'm gonna add one element to a 4 well what happens well first thing that happens is append is a mutating method and so it says hey I'm this thing called a copy on right type so I want to check to see if I'm the only user of this data and turns out no lots of other things are pointing to our data here and so lazily because it's shared I'll make a copy of this array and so I only get a copy of the data if it's shared and if it changes so that should be one two three yeah that should be one two three ninety-two I am buggier than Swift now the interesting thing about this is because of the way this all works out is if you go and you change a four again it goes and just updates it in place there's no extra copy and so the cool thing about this is that you get exactly the right number of copies and it just works you as a programmer don't have to think about this this is one of the things that Swift is just like subtracting from your consciousness of the things you have to worry about which is really nice and so a really nice aspect of this is that you get algebra like values work the way values are supposed to work you get super high performance we get to use more emojis which I always appreciate if you want to learn more about this because this is also a really cool deep topic that you can geek out about particularly if you've done object or your programming before there's a lot that's really nice about this there's a video you can see more so let's go back to that Auto diff thing and let's actually talk about auto-da-fé from a different perspective so this is the auditive system implemented the same way as the the manual manually done high torques version and we didn't like it because it was using references let's implement again the very low-level manual way in Swift but before we do let's talk about where we want to get to so Swift has built in in Swift for test flow has built in automatic differentiation for your code so you don't have to write gradients manual you don't have to worry about all the stuff and the way it works is really simple there are functions like gradient and you call gradient and you pass it a closure and you say what is the gradient of X times X and it gives you a new function the computes the gradient of x times X and here we're just calling that function on a bunch of numbers that were striding over and printing them out and it just gives you this gradient of this this random little function we wrote now one of the interesting things about this is I wrote this out it takes just doubles or floats or other things like that Auto difference works on any differential type anything that's continuous anything that's not like integers anything that has a gradient and so so you can't do this in just a library this has to be built into the language itself because you're actually you're just you're literally compiling something that's multiplying doubles together and the tests and figure out how to get gradients yeah you can do things as a library and that's what pi torch and other frameworks do in the proper height or it doesn't work the same way at all I touch will not do that on doubles might work oh yeah I do that on sensors yes yes and so and so this this doesn't just work on doubles if you want to define a quarter nians or other cool numeric scientific key things that are continuous those are differentiable too and that all stacks out and works so the there's a bunch of cool stuff that works this way you can define a function you can get the gradient at some point with the function you can pass some closures like all this stuff is really nice instead of talking about that we're gonna do the from the bottom up thing and so I'm gonna pretend I understand calculus for a minute which is sad so if you think about what differentiation is competing with the derivative of a function there's two basic things you have to do you have to know the axioms of the universe like what does what is the derivative of plus or multiply or sine or cosine or tensor or map ball then you have to compose these things together and the way you compose them together is the same called the chain rule and this is something that I relearned sadly over the last couple of weeks and I'm that we did in the Python part of his classes yes and we wrote it a different way we had 2y DX equals 2y 2 u 2 u DX apparently there are some ancient feud between the people who invented calculus independently and they could not agree on notation I murderer so so what this is saying is saying if you want the derivative of F calling G the derivative of F calling G is the derivative of F applied to the forward version of G multiplied by the derivative of G and this is important because this is actually computing the for version of G and in order to get the derivative of this and so which we kind of hate away and out 2 y 2 u 2 u DX version sure I don't know how to do it on your machine there you go so so how are you gonna do this well what we're gonna do is we're gonna look at defining the forward function of this and so we'll use the main screen they're mean squared error as the example function this is a little bit more complicated than I want and so what I'm going to do is I'm going to actually just look at this piece here and so I need to find this function MSE inner and all it is is this the dot squared dot mean so it's conceptually this thing and I see inter that just gets the square of X and then doesn't mean just because that's simpler and then we'll come back to MSE at the end and so in order to understand what's going on I'm going to find this little helper function called trace and all trace does is it you can put it in your function and it uses this little magic thingy called pound function and when you call trace it just prints out the function that it's called from ok and so here we call foo and it prints out hey I'm in foo a B and I'm in bar X and so we'll use that to understand what's what's happening in these cells so here I can define just like you did in the pie preserving the forward and the the derivative versions of these things and so x times x is the forward the gradient version is two times X X dot mean is the forward this weird thing of doing a divide is apparently the gradient of mean and I checked it apparently works I don't know why so then when you define the fork function of this MSC in a function it's just saying give me the square and and take them in super simple and then we can use the chain rule and this is literally where we use the chain rule to say okay we want the gradient of one function on another function just like the syntax shows and the way we do that is we get the gradient of mean and pass it to the inner thing and multiply by the gradient of the other thing and so this is really literally the math interpretation of this stuff and given that we have this we can now wrap it up in two more functions and we can say let's compute the forward and the backward version of MSC will you just call the forward version we call the backward version and we can run on some example data one two three four I just be clear the upward upside-down triangle thing is not an operator here it's just using Unicode as part of the name of that function that's a gradient Delta symbol thingy I found that in Wikipedia so when you run this what you'll see is it computes the ford ford version the saint runs square and then it runs mean and then it won't square again and then it runs the backward version of mean and square and this makes sense given the chain rule right we have to recompute the forward version of square to do this and for this simple example that's fine square is just one multiply but consider it might be a multiply of megabytes worth of stuff it's not necessarily cheap and when you start composing these things together this recomputation can really come back to bite you so let's look at what we can do to factor that out so there's this pattern called chain errs and what we call the value and chain or pattern and what we want to do is we want to find each of these functions like square or a mean or your model as one function that returns two things and so what we're going to do is we're going to look at the the other version of calculus is form of this and so when you say that the derivative of x squared is 2x you actually have to like move the DX d DX over with it and this matters because the functions we just defined are actually only those are only valid if you're looking at a given point that they're not valid if you compose it with another function and it's another way of writing the chain rules the exact same thing and so we're gonna call this the gradient chain and all it is is an extra multiplier I just need to warn you in one of the earlier courses I got my upside-down triangles mixed up as you just did so that's not the other way around is tilter and this one is for nabla and I only know that because I got in trouble for screwing it up okay that last time Thank You Jeremy for saving me so so all this is it's the same thing we saw before it just has an extra multiplication there because that's what the chain rule apparently really says so what we can do now is now that we have this we can actually define this value with chain function and check the so what this is doing is this bring up both of these things into one thing so here we're returning the value when you call this we're also returning this chain function and since you explained this TF arrow TF like so what this is doing is this is saying we're defining a function square WV see it takes X it returns a tuple right we know what tuples are these are fancy tuples like you were showing before where the two things are labeled so there's a value member of the tuple and there's a chain label of the tuple the value is just a tempura flour the chain is actually going to be a closure and so this says it is a closure that takes a tensor a float and returns a tensor afloat so that's just a way of defining a type in Swift where the type is itself yep and so what square vwc is gonna be is this going to be two things it's the forward thing the multiply x times X and then it's the backwards thing the thing we showed just up above that does DDX times 2 times X and the forward thing is the actual value of the forward thing that the backward thing is a function that will calculate the backward and the chain here is returning it closure and so it's not actually doing that computation so we can do the same thing with mean and there's the same computation and so now what this is doing is this a little abstraction that allows us to pull together the forward function and the backward function into one little unit and the reason why this is interesting is we can start composing these things and so this MSE inner thing that we were talking about before which is mean followed by square or square followed by mean we can define we just call square vwc and then we pass the value that it returns into the mean vwc and then the result of calling this thing is mean top value and the derivative is those two chains stuck together and so if we run this now we get this really interesting behavior where when we call it we're only calling the forward functions once and the backward function once as well and we also get the ability to separate this out and so here what we're doing is we're calling the vwc for the whole computation which gives us the two things and here we're using the value so we got the forward version of the value and if that's all we want that's cool can stop there but we don't we want the backward version too and so here we call it with we called the chain function to get that derivative and so that's what gives us both the ability to get the forward and the backward separate which we need but also it makes it so we're not getting the recomputation because we're reusing the same values within these closures so so given that we have these like infinitesimally tiny little things let's talk about applying this pattern I'll go pretty quickly because the details aren't really important so r lu is just max with zero and so we're using the same the same thing as well you grad from before here's the lin grad using the pi torch style of doing this and so all we're doing is we're pulling together the ford computation in the value thing here and then we're doing this backward computation here and we're doing this with closures so I kind of talk about this difference but it's likely to be interesting because you know this is the vision that Silva and I wrote when we just pushed it over from from from PI torch and we actually did the same thing that Chris just did which is we avoided calculating the forward pass twice and the way we did it was to cache away in in dot grad and out grad the the and and you know the intermediate values so that we could then use them again later without recalculating them now what Chris is showing you here is doing the exact same thing but in a much more automated way right it's a very mechanical process yeah so rather than having to use this kind of very heuristic hacky one-at-a-time approach or saying what do I need at each point let's save it away in something we'll give it a name and then we'll use it again later it's kind of interesting and it also without without any mutation this functional approach is basically saying let's package of everything we need and hand it over to everything that needs it and so that way we never had to say what are we going to need for later it just it just works so it kind of like you'll see all the steps are here out times blood or transposed out times model transposed right but we never had to think about what to cash away and so the the this is not something I would want to write ever again manually personally but the advantage of this is it's really mechanical in this very structure and so when you write MSE the full embassy what we can do is we can say well it says subtraction then a set mean squared and then on the backwards pass we have to undo that the squeeze and the subtraction thingy and so it's very mechanical how plugs together now we can write that forward and backward function it looks very similar to what the the manual version of the PI torch thing look like where you're calling these functions and then in the backward version you start out with one because the gradient of the loss with respect to itself is one which now I understand thanks to Jeremy and then they chain all together and you get the gradients and through all this work again what we've ended up with is we've gotten the forward and backwards past we get the gradients of the thing and now we can do optimizers and apply the updates now the just mention like what Chris was saying about this this this one thing here and so forth so Chris and I we took a really long time to get to this point and we found it extremely difficult and at every point up until the point where it was done we were totally sure we weren't smart enough to do it yes and so like please don't worry that there's a lot here and that you might be feeling the same way Chris and I did but yeah you'll get there right it's it this this was a harrowing journey yeah it's it's okay if this seems tricky but yes so if you reached out one at a time yeah but so again this is this is talking about the low-level low-level mathy stuff that underlies calculus and so the cool thing about this though from the Swift perspective is this is mechanical and compilers are good at mechanical things and so one of the things that we've talked about a lot and this this course is the idea of there are primitives there are the atoms of the universe and then there are things you build out of them and so the atoms of the universe for tense are the atoms of the universe for float we've seen right and so we've seen multiply and we've seen add-on floats well if you look at the perimeters of the universe for tensor there methods and they call the raw ops that we showed you last time right and so the if you go look at the tensor flow API is what you'll see is those atoms have this thing that swift calls on VJ PS for weird reasons this defines exactly the mechanical thingy that we showed you and so the atoms know what their derivatives are and the compiler doesn't have to know about the atoms but that means that if you want to you can introduce new atoms that's fine the payoff of this now though is you don't have to deal with any of this stuff so that's that's the upshot what I can do is I can define a function so here's MSC in ER and it just does squared that mean and I say give make it differentiable and I can actually get that that weird thing that that chain or thing directly out of it and I can get direct low-level access if for some reason I ever wanted to generally you don't and that's why you say give me the gradient or give me the value and the creative and so this stuff just works and the cool thing about this is this all stacks up from very simple things and it composes in a very nice way and if you want to you can now go hack up the internals of the system and play around with the guts and it's exposed and open for you but if you're like me at least you would stay away from it and just just right now I mean sometimes we do need it right so you'll remember when we did the the heat maps right to Kepler those heat maps we actually have to dive into the you know registering a backward callback in PI torch and grab the gradients and then use those in our calculations and so you know stuff we come across where you actually need to give up with this yeah and there are some really cool things you can do too so now let's we ended up with with the model and so this is something that I'd never got around to doing the fix me so here's our Ford function here we're implementing it with Matt moles and with the Len function the values and things like that the bad thing about defining a forward function like this is you get tons of arguments to your function and so some of these arguments are things that you want to feed into the model some of these things are parameters and so as we're factoring what we can do is we can introduce strucked you might be surprised that puts all of our parameters into it so here we have my model and we're saying it is differentiable and what differentiable means is has a whole bunch of floating-point stuff in it and I want to get the gradient with respect to all of these okay so now I can shove all those arguments into the struct it gives me a nice capsule to deal with and now I can use the forward function on my model I can declare it as a method this is starting to look nicer this is more familiar and I can just do math and I can use W 1 and B 1 and these are just values to find on our struct now I can get the gradient with respect to the whole model and our loss right and all of this is building up on top of all those different primitives that we saw before that we in the chain rule and all these things that now said we can say hey give us the gradient of the model with respect to X train and white train and we get all the gradients of W 1 B 1 W 2 B 2 and all this stuff works you can see it all calling the low functions that we wrote and it's all pretty fast now again like we were just talking about this is not something you should do for Matt mole or a convolution but there are reasons why this is cool and so there there are good reasons and they're annoying reasons I guess so sometimes the gradients you get out of any auto-da-fé system will be slow because you do ton of computation and it turns out the gradient ends up being more complicated and sometimes you want to do an approximation and so it's actually really nice you can say hey here's the forward version of this big complicated computation I'm gonna have an approximation that just runs faster sometimes you'll get numerical instabilities in your gradients and so you can define again a different implementation of the backwards pass which can be useful for exotic cases there are some people on the far research side of things that want to use like learning and things like that to learn gradients which is cool and so having the system where everything is just simple and composes but as hackable is really nice they're also always going to be limitations of the system now one of the limitations that we currently have today but will hopefully be fixed by the time video comes out is we don't or control flow and auto-da-fé and so if you do an if or a loop like an RNN auto-da-fé will say i don't support that yet but that's okay because you can do it yourself so we'll go see an example of that in 11 and so what we have implied here and we'll talk about layers more in a second is we have this thing called switchable layer and with switchable layer is it's just a layer that allows us to have a boolean toggle to turn it on and off and the on and off needs an if right and so Swift auto-da-fé doesn't currently sport if but and so when we define the Ford function is super easy we just check to see if it's on and if so we run the forward otherwise we don't because it doesn't support that control flow yet we have to write the backwards pass manually and we can do that using exactly all the stuff that we just showed we implement the value and we implement the chain or thing and we can implement it by returning the right magic set of closures and stuff like that and so you know it sucks that Swift doesn't support this but it's an infinitely hackable system and so for this or anything else you can go and customize it to your heart's content yeah and I mean the one of the key things here is that Chris was talking about kind of the the atoms and at the moment the atoms is is tensorflow which is way too big an atom it's a very large atom but at the point when we're kind of in Emily our world that atoms are the things going on inside you're a little tunnel DSL that you've written and so this ability to actually differentiate on float directly suddenly become super important because it means that like I mean for decades people weren't doing much research he stuff with deep learning and one of the reasons was that none of us could be bothered implementing a accelerated version of every damned you know you know cooter operation that we needed to do the backward pass of and do the calculus blah blah blah nowadays we only work with a subset of things that like PI torch and stuff already supports so at the point where you know this is that about why we're doing this stuff with Swift now is that this this is the foundations of something that in the next year or two will give us all the way down infinitely hackable fully differentiable system yep can we can we jump to layer really quick so so we've talked about Matt mole we've talked about auto-da-fé now let's talk about other stuff so layers that are now super easy it just uses all the same stuff you've seen and so if you go look at layer it's a protocol just like we were talking before and layers are differentiable like they contain bags of parameters just like we just saw the requirement inside of a layer is you have to have a call so the layers and Swift are callable just like you'd expect and they have they work with any type that's an input or output and what later says is the input and output types just have to be differentiable and so layer itself is really simple yep and so underneath here you can see us to finding a few different layers so for example here is the definition of a dense layer right and so then now that we've got our layers and we've got our forward pass that's enough to actually allow us to do many batch training and I'm not going to go through all this in any detail other than just to point out that you can see here is defining a model and it's just a layer because it's just a differentiable thing that has a Col function and you can call the model layer we can define log softmax we can define negative log likelihood log some X once we've done all that we're allowed to use the Swift 40s version because we've done it ourselves and at that point we can create a training loop so we ought to find accuracy just like we did in play torch setup a mini batch just like we did in play torch and at this point we can create a training loop so we just go through and grab our x and y and update all of our things you'll notice that when there's no torch no grant here and that's because in Swift you opt into gradients not out of gradients so it's you wrap the stuff that once gradients inside value with gradient and there we go so we've got a record of training loop now one really cool thing is that all of these things and packaged up together thanks to the layer protocol into a thing called variables which which layer is differentiable yes rentable is also a protocol protocols have lots of cool stuff on them so thanks to that we don't have to write anything else we can just say model dot variables - equals a lot of times grad and it just works thanks to the magic of protocol extensions our model got that for free because we said it's a layer yep okay so I think that's about all we wanted to show there so now that we've got that we're actually allowed to use optimizers so we can just use that instead and that gives us a standard training loop which we can use and then on top of that we can add callbacks which I won't go into the details but you can check it out in zero four and you will find that find them here we go we'll find a loaner class which has the same callbacks that we're used to and then eventually we'll get to the point where were you actually written a stateful optimizer with hyper parameters again just like we saw in PI torch and most of this will now look very familiar we won't look at dictionaries now but they're almost identical to PI torch dictionaries and we use them in almost the same way so you see we've got States and steppers and stats just like in play torch and so eventually you'll see we have things like the lam optimizer written in Swift which is pretty great and it's the same amount of code and things liked squared derivatives we can use on our store Unicode to make them a bit easier to see and so now we have a function created SGD optimizer a function to create an atom optimizer we have a function to do one cycle scheduling and thanks to matplotlib we can yep so it's also yeah this is really the power of the abstraction coming back to one of the earlier questions of earlier today we started in C and we're talking about very abstract things like protocols and how things fit together but when you get those basic things and this is one of the reasons why learning swift goes pretty quickly you get the basic idea and now it applies everywhere yeah and here we are doing mix up and it's so now we're in 10 and here we are doing label smoothing and just say it's it's really very similar looking code to what we have in pi torch so then by the time we get to 11 other than this tacky workaround for the fact that we can't do control flow differentiation yet coming very soon Durex ResNet as you've seen looks very similar and we can train it in the usual way and there we go so we've kind of started with nothing and Chris spent a couple of decades for us first Patrol building a compiler framework and then a compiler and then a C compiler that a C++ compiler than a new language then the compiler for that language and then we came in and let me correct you on one minor detail some people helped you yeah like I did not build all the stuff like amazing people that I got to work with built all of this stuff so cool and likewise like all of these workbooks were built by amazing people that we were lucky enough to work with yeah absolutely so that's what happened and then let's look at so like it's kind of like thanks to all that work we we then got to a point where 18 months ago you and I met you just joined Google we were at the tensorflow symposium and I said what are you doing here I thought you're a compiler guy and he said oh well now I'm gonna be a deep learning guy well then I said what deep learning sounds really cool yeah and he hadn't told me it was uncool yet yeah so then I complained about how terrible everything was and Chris said so Chris said I gotta create a new framework and I was like we need a lot more and a new framework you know we described the problems that we've talked about with like where pythons up to Chris said well I might actually be creating a new language the deep wedding which I was very excited about so I'm totally not happy with the current languages we have for deep learning so then 12 months ago I guess we started asking this question if like what if high-level API design actually influenced the creation of a differentiable programming language what would that what would that mean and so to me one of the dreams is when you connect the building of a thing with teaching of the thing with using a thing in reality and one of the beautiful things about fast AI is pulling together both building the framework teaching the framework and doing research with the framework yeah so so next time we caught up I said maybe we should try riding faster yeah and Swift and you're like we could do that I guess like right well sorry I think the one thing before this I'm like hey Jeremy it's starting to work yeah and he says oh cool can we ship it yet I'm like yeah it's starting and it's a high level API yes let's advance the course where we teach people to use this thing that doesn't exist yet and and I think I said naively I like deadlines deadlines are a good thing they force progress to happen so then one month ago we created a github repo and we put a notebook a that and we cut that allows tensorflow dev summit we sat in a room with the Swifter tensorflow team and we wrote first line of the first notebook and you told your team hey we're gonna write all of the Python dog books from scratch and they basically said what do you have got us into so and I think we've learned a lot yeah so I mean to me the question is still this which is what if high-level API design was able to influence the creation of a differentiable programming language and I guess we've started answering that question yeah I don't think we're there yeah i'm ii I think that what we've learned even over the last month is that there's still a really long way to go and I think this is the kind of thing that really benefits from different kinds of people and perspectives and different different set of challenges and just just today and yesterday working on datablocks a breakthrough happen where there's an entirely new way to reimagine it as this functional composition that solves a lot of problems and yeah a lot of those kinds of breakthroughs I think are still just waiting to happen and it's been an interesting process for me Chris like because we decided to go back and redo the Python library from scratch it and-and-and-and as we did it we were thinking like what would this look like when we get to Swift and so we you know even as we did read at the Python library we created the idea of stateful optimizers we created the the new callbacks version two so that was interesting but there's also been interesting I've seen from as an outsider from a distance that Swift syntax seems to be changing thanks to some of this yeah absolutely so there are new features in Swift including cobbles that's a thing that exists because of Swiffer tensorflow the Python interoperability believe it or not we drove that because it's really important for what we're doing there's a bunch of stuff like that that's already being driven by this project and I think there's gonna be more and so like making it so float can default away to nothing that's really important we have to do that and otherwise it won't have been a priority so I mean so it's still really really early days and and I think the question in my mind is now like what what will happen when data scientists in lots of different domains have access to an infinitely hackable differentiable language along with the world of all of the C libraries you know like what what do we end up with because we kind of we have we're starting from very little in terms of ecosystems in Swift we haven't covered for examples I mean called K paths but there's this thing called K paths which might let us write like little query language deer cells in Swift with type safety yeah give me give me all the parameters are the same and let me do something interesting to them yeah it's really cool and so you know I guess at this point I'm kind of saying that people is like pick some piece of this that might be interesting in your domain and over the next 12 to 24 months explore with us so that you know as this as Chris said good of putting this aeroplane together whilst it's flying you know by the time it's actually the all the pieces are together you'll have your domain-specific pieces together and I think it'll be super exciting and what one of the things that's also really important about this project is it's not cast in concrete so we can and we will change it to make it great and to me we're very much in the phase of let's focus on making the basic ingredients that everybody puts things together like let's talk about the core of layer is let's talk about what datablock should be let's talk about what all these basic things are let's not mess with float anymore grab a few always done yeah if we can consider float done but but let's actually really focus on getting leads right so that then we can build amazing things on top of them and to me the thing I'm looking forward to is just innovation now the thing innovation happens when you make things that are previously hard accessible to more people and that's what I would just love to see so the thing I keep hearing is how do I get involved so like I I think there's many places you can get involved but like to me the best way to get involved is by trying to start using little bits of this in work that you're doing or utilities you're building your hobbies you have you know trip just try you know it's it's not so much how do I add some new custom derivative thing into Spencer flow but it's like you know implement some notebook that didn't exist before or take some Python library that you've liked using and try and create a swift do try something write a blog post I mean so one of the things when sweat first came up is that a lot of people were blogging about their experiences and what they learn and what they liked and what they didn't like and that's an amazing communication channel because the team listens to that and that's a huge feedback loop because we can see somebody was struggling about it and even over the last couple of weeks when Jeremy complains about something we're like oh that is really hard maybe we should fix that and we do change it and then progress happens right yeah so we want we want that feedback loop in blogs and other kinds of yeah it's a very receptive very receptive sure yeah were there any uh highlight questions that you wanted to ask before we wrapped up rich oh really okay well I mean let me say this Chris it's been an absolute honor and absolute pleasure to get to work with you and with your team it's like a dream come true for me and to see what is being built here and you're always super humble about your influence but I mean you've been such an extraordinary influence in in all the things that you've helped make happen and I'm super thrilled for our little community that you've let us piggyback on yours a little bit I'm thank you so much oh and from my perspective as a tool builder right tool builders exists because of users and I want to build a beautiful thing and I think everybody working on the project wants to build something that is really beautiful really profound that enables people to do things they've never done before I'm probably excited to see that I think we're already seeing that study that happened so thank you so much and thanks everybody for joining us rather than see you on the forum